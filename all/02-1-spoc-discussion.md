#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。
 > UEFI是BIOS的一种升级替代方案。关于BIOS和UEFI二者的比较，如果仅从系统启动原理方面来做比较，UEFI之所以比BIOS强大，是因为UEFI本身已经相当于一个微型操作系统，其带来的便利之处在于：首先，UEFI已具备文件系统的支持，它能够直接读取FAT分区中的文件。其次，可开发出直接在UEFI下运行的应用程序，这类程序文件通常以efi结尾。最后，不再需要主引导记录，不再需要活动分区，不需要任何工具，只要复制安装文件到一个FAT32（主）分区/U盘中，然后从这个分区/U盘启动，安装Windows就是这么简单。
 1. 描述PXE的大致启动流程。
 > 客户端个人电脑开机后， 在 TCP/IP Bootrom 获得控制权之前先做自我测试。Bootprom 送出 BOOTP/DHCP 要求以取得 IP。如果服务器收到个人电脑所送出的要求， 就会送回 BOOTP/DHCP 回应，内容包括客户端的 IP 地址， 预设网关， 及开机映像文件。否则，服务器会忽略这个要求。Bootprom 由 TFTP通讯协议从服务器下载开机映像文件。个人电脑通过这个开机映像文件开机， 这个开机文件可以只是单纯的开机程式也可以是操作系统。开机映像文件将包含 kernel loader 及压缩过的 kernel，此 kernel 将支持NTFS root系统。远程客户端根据下载的文件启动机器。

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 > 1、电源自检程序开始运行;2、主引导记录被装入内存，并且程序开始执行;3、活动分区的引导扇区被装入内存;4、NTLDR从引导扇区被装入并初始化;5、将处理器的实模式改为32位平滑内存模式;6、NTLDR开始运行适当的小文件系统驱动程序。7、NTLDR读boot.ini文件;8、NTLDR装载所选操作系统;9.Ntdetect搜索计算机硬件并将列表传送给NTLDR，以便将这些信息写进\\HKE Y_LOCAL_MACHINE\HARDWARE中。10.然后NTLDR装载Ntoskrnl.exe，Hal.dll和系统信息集合。11.Ntldr搜索系统信息集合，并装载设备驱动配置以便设备在启动时开始工作;12.Ntldr把控制权交给Ntoskrnl.exe，这时,启动程序结束,装载阶段开始
 1. 了解GRUB的启动流程。
 > 装载stage1；装载stage1.5；装载stage2；读取/boot/grub.conf文件并显示启动菜单；装载所选的kernel和initrd文件到内存中。
 1. 比较NTLDR和GRUB的功能有差异。
 > 在X86架构的机器中，Linux、BSD 或其它Unix类的操作系统中GRUB、LILO是大家最为常用，应该说是主流。Windows也有类似的工具NTLOADER；NTLOADER就是一个多系统启动引导管理器，NTLOADER 同样也能引导Linux，只是极为麻烦罢了。
 1. 了解u-boot的功能。
 > u-boot是一种普遍用于嵌入式系统中的Bootloader,Bootloader是在操作系统运行之前执行的一小段程序，通过它，我们可以初始化硬件设备、建立内存空间的映射表，从而建立适当的软硬件环境，为最终调用操作系统内核做好准备。Boot Loader的主要运行任务就是将内核映象从硬盘上读到RAM中，然后跳转到内核的入口点去运行，即开始启动操作系统。系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的Boot Loader程序。

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
 > 中断：键盘输入；异常：除零，缺页，段错误，
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)
 > Linux全部系统调用只有250个左右。系统调用主要分为以下几类：控制硬件——系统调用往往作为硬件资源和用户空间的抽象接口，比如读写文件时用到的write/read调用。设置系统状态或读取内核数据——因为系统调用是用户空间和内核的唯一通讯手段，所以用户设置系统状态，比如开/关某项内核服务（设置某个内核变量），或读取内核数据都必须通过系统调用。比如getpgid、getpriority、setpriority、sethostname。进程管理——一系统调用接口是用来保证系统中进程能以多任务在虚拟内存环境下得以运行。比如 fork、clone、execve、exit等

```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 > 有sys_exit，sys_fork，sys_open等共22个；主要分类有文件操作，进程管理，内存管理等。
 
 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
 > objdump可以分析这个可执行程序的代码，输入-d的话可以看到所有函数的汇编代码，输入其他参数可以看到版本、头文件等信息；nm则可以看到这个程序使用的所有符号；file的输出为ELF 64-bit LSB executable, x86-64, version 1(SYSV),dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID..., not stripped。它给出了这个文件的具体信息，比如它是可执行程序，64位，动态链接，在linux下运行等。

 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 > strace显示了这个程序的所有系统调用，以及出现的错误次数和耗时。linux的系统调用过程为：首先是brk 和 mmap2等进行动态加载的分配空间和检查（access);然后是搜索检查标准库（open read fstat);接着是标准库加载并初始化（mmap,arch_prctl,mprotect)。最后执行write函数并退出。

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行代码，分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
   1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
   > int :产生需要马上处理的中断信息,引发中断过程.iret :从中断中恢复中断前的状态,中断服务程序的最后一条指令。IRET指令将推入堆栈的段地址和偏移地址弹出，使程序返回到原来发生中断的地方。call: 进行跳转，跳转之前保存返回地址（下一条指令的地址），以便在跳转目标代码。ret: 子程序的返回，当前堆栈指针减2,返回之前的指令地址。int iret 用于系统调用 ，堆栈切换和特权级的转换 call和ret 常规调用 ，没有堆栈切换
